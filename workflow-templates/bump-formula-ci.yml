name: Bump Formula CI

on:
  release:
    types: [released]

env:
  TAP_REPO_PATH: ${{ github.repository_owner }}/homebrew-public

jobs:
  examine-release:
    name: Examine the release
    runs-on: ubuntu-latest
    steps:
      - name: Exract release info
        id: release-info
        env:
          GH_TAG_REF: ${{ github.ref }}
        shell: python3 {0}
        run: |
          import os, re, sys

          # Extract tag name
          tag_ref = os.environ['GH_TAG_REF']
          tag_name = re.match(
            r"^(?:refs/tags/(?P<tag>.*))",
            tag_ref
          ).group("tag")

          print("tag of the release: {tag_name}".format(tag_name=tag_name))
          print("::set-output name=tag::{tag_name}".format(tag_name=tag_name))

          # NOTE: some repositories don't use SemVer scheme
          # Extracts version, excludes prerelease
          version_match = re.match(r"^v?(?P<version>\d[\d\.]*)", tag_name)

          if version_match:
            version = version_match.group("version")
            print("version: {version}".format(version=version))
            print("::set-output name=version::{version}".format(version=version))
          else:
            # FIXME: fix error message
            err_msg = "Release tag does not look like a version tag."
            print("::error file=PLACEHOLDER,line=1,col=1::{err_msg}".format(err_msg=err_msg))
            sys.exit(err_msg)

      - name: Checkout tap repo
        if: ${{ success() }}
        uses: actions/checkout@v2
        with:
          repository: ${{ env.TAP_REPO_PATH }}
          path: tap_repo

      - name: Search formula by url
        id: search-formula
        if: ${{ success() }}
        env:
          LIB_REPO: ${{ github.repository }}
        shell: python3 {0}
        run: |
          import os, re, sys, pathlib, concurrent.futures

          url_regex = re.compile(
            r"^ *url +(?P<quote_type>[\"\'])https://github\.com/{repo_path}/".format(repo_path=os.environ['LIB_REPO']) + \
            r"(?:(?P<archive>archive)|(?P<release>releases/download))/" \
            r"(?P<tag>v?(?P<version>\d[\d\.]*))" \
            r"(?(archive)|(?(release)/(?P=REPO_NAME)\-(?P=version)|))\.(?:tar\.gz|zip)(?P=quote_type)$",
            lib_repo,
            re.MULTILINE
          )

          def inspect_formula(path):
            with path.open(mode='r') as f:
              formula_match = url_regex.search(f.read())

            if formula_match:
              print("found formula at: {path}".format(path=path))
              return (path, formula_match)
            else:
              return False

          formula_paths = list(pathlib.Path("tap_repo/Formula").glob("*.rb"))
          with concurrent.futures.ThreadPoolExecutor(max_workers=None) as executor:
            matched_formulas = [path for path in executor.map(inspect_formula, formula_paths, chunksize=1) if path not False]

          if len(matched_formulas) == 0:
            # FIXME: fix error message
            err_msg = "Formula not found."
            print("::error file=PLACEHOLDER,line=1,col=1::{err_msg}".format(err_msg=err_msg))
            sys.exit(err_msg)

          elif len(matched_formulas) > 1:
            # FIXME: fix warning message
            warn_msg = "Found multiple formulas having qualifying URL: {paths}".format(
              paths=", ".join([p.name for p in matched_formulas])
            ) + ", will use the first one."
            print("::warning file=PLACEHOLDER,line=1,col=1::{warn_msg}".format(warn_msg=warn_msg))

          # Set outputs
          formula_filepath, formula_match = matched_formulas[0]

          print("::set-output name=formula_path::{formula_filepath}".format(formula_filepath=formula_filepath))
          print("::set-output name=formula_name::{formula_name}".format(formula_name=formula_filepath.stem))

          formula_group = formula_match.groupdict()
          if formula_group.get("archive"):
            print("::set-output name=url_type::archive")
          elif formula_group.get("release"):
            print("::set-output name=url_type::release")
          else:
            # FIXME: fix error message
            err_msg = "Formula parser matched some undocumented URL format."
            print("::error file=PLACEHOLDER,line=1,col=1::{err_msg}".format(err_msg=err_msg))
            # TODO: set exit code 1 or raise some exception
            pass